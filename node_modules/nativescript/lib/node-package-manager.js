"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
const path = require("path");
class NodePackageManager {
    constructor($fs, $hostInfo, $errors, $childProcess, $logger, $options) {
        this.$fs = $fs;
        this.$hostInfo = $hostInfo;
        this.$errors = $errors;
        this.$childProcess = $childProcess;
        this.$logger = $logger;
        this.$options = $options;
    }
    install(packageName, pathToSave, config) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.$options.disableNpmInstall) {
                return;
            }
            if (this.$options.ignoreScripts) {
                config = config || {};
                config["ignore-scripts"] = true;
            }
            let packageJsonPath = path.join(pathToSave, "package.json");
            let jsonContentBefore = this.$fs.readJson(packageJsonPath);
            let dependenciesBefore = _.keys(jsonContentBefore.dependencies).concat(_.keys(jsonContentBefore.devDependencies));
            let flags = this.getFlagsString(config, true);
            let params = ["install"];
            if (packageName !== pathToSave) {
                params.push(packageName);
            }
            params = params.concat(flags);
            let pwd = pathToSave;
            if (this.$options.path) {
                let relativePathFromCwdToSource = "";
                if (this.$options.frameworkPath) {
                    relativePathFromCwdToSource = path.relative(this.$options.frameworkPath, pathToSave);
                    if (this.$fs.exists(relativePathFromCwdToSource)) {
                        packageName = relativePathFromCwdToSource;
                    }
                }
            }
            try {
                let spawnResult = yield this.$childProcess.spawnFromEvent(this.getNpmExecutableName(), params, "close", { cwd: pwd, stdio: "inherit" });
                this.$logger.out(spawnResult.stdout);
            }
            catch (err) {
                if (err.message && err.message.indexOf("EPEERINVALID") !== -1) {
                    this.$logger.warn(err.message);
                }
                else {
                    this.$fs.writeJson(packageJsonPath, jsonContentBefore);
                    throw err;
                }
            }
            let jsonContentAfter = this.$fs.readJson(path.join(pathToSave, "package.json"));
            let dependenciesAfter = _.keys(jsonContentAfter.dependencies).concat(_.keys(jsonContentAfter.devDependencies));
            let dependencyDiff = _(jsonContentAfter.dependencies)
                .omitBy((val, key) => jsonContentBefore && jsonContentBefore.dependencies && jsonContentBefore.dependencies[key] && jsonContentBefore.dependencies[key] === val)
                .keys()
                .value();
            let devDependencyDiff = _(jsonContentAfter.devDependencies)
                .omitBy((val, key) => jsonContentBefore && jsonContentBefore.devDependencies && jsonContentBefore.devDependencies[key] && jsonContentBefore.devDependencies[key] === val)
                .keys()
                .value();
            let diff = dependencyDiff.concat(devDependencyDiff);
            if (diff.length <= 0 && dependenciesBefore.length === dependenciesAfter.length && packageName !== pathToSave) {
                this.$logger.warn(`The plugin ${packageName} is already installed`);
            }
            if (diff.length <= 0 && dependenciesBefore.length !== dependenciesAfter.length) {
                this.$logger.warn(`Couldn't install package ${packageName} correctly`);
            }
            return diff;
        });
    }
    uninstall(packageName, config, path) {
        return __awaiter(this, void 0, void 0, function* () {
            let flags = this.getFlagsString(config, false);
            return this.$childProcess.exec(`npm uninstall ${packageName} ${flags}`, { cwd: path });
        });
    }
    search(filter, config) {
        return __awaiter(this, void 0, void 0, function* () {
            let args = ([filter] || []).concat(config.silent);
            return this.$childProcess.exec(`npm search ${args.join(" ")}`);
        });
    }
    view(packageName, config) {
        return __awaiter(this, void 0, void 0, function* () {
            const wrappedConfig = _.extend({}, config, { json: true });
            let flags = this.getFlagsString(wrappedConfig, false);
            let viewResult;
            try {
                viewResult = yield this.$childProcess.exec(`npm view ${packageName} ${flags}`);
            }
            catch (e) {
                this.$errors.failWithoutHelp(e);
            }
            return JSON.parse(viewResult);
        });
    }
    getNpmExecutableName() {
        let npmExecutableName = "npm";
        if (this.$hostInfo.isWindows) {
            npmExecutableName += ".cmd";
        }
        return npmExecutableName;
    }
    getFlagsString(config, asArray) {
        let array = [];
        for (let flag in config) {
            if (flag === "global") {
                array.push(`--${flag}`);
                array.push(`${config[flag]}`);
            }
            else if (config[flag]) {
                if (flag === "dist-tags" || flag === "versions") {
                    array.push(` ${flag}`);
                    continue;
                }
                array.push(`--${flag}`);
            }
        }
        if (asArray) {
            return array;
        }
        return array.join(" ");
    }
}
exports.NodePackageManager = NodePackageManager;
$injector.register("npm", NodePackageManager);
