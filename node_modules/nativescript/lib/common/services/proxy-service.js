"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
const path = require("path");
const os_1 = require("os");
const constants_1 = require("../constants");
class ProxyService {
    constructor($credentialsService, $fs, $options, $staticConfig) {
        this.$credentialsService = $credentialsService;
        this.$fs = $fs;
        this.$options = $options;
        this.$staticConfig = $staticConfig;
        this.proxyCacheFilePath = path.join(this.$options.profileDir, constants_1.Proxy.CACHE_FILE_NAME);
        this.credentialsKey = `${this.$staticConfig.CLIENT_NAME}_PROXY`;
    }
    setCache(cacheData) {
        this.$fs.writeJson(this.proxyCacheFilePath, cacheData);
        return cacheData;
    }
    getCache() {
        return this.$fs.exists(this.proxyCacheFilePath) && this.$fs.readJson(this.proxyCacheFilePath);
    }
    clearCache() {
        this.$fs.deleteFile(this.proxyCacheFilePath);
        this.$credentialsService.clearCredentials(this.credentialsKey);
    }
    getInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            let message = "";
            const proxyCache = this.getCache();
            if (proxyCache) {
                const proxyCredentials = yield this.getCredentials();
                message = `Proxy Url: ${proxyCache.PROXY_PROTOCOL}//${proxyCache.PROXY_HOSTNAME}:${proxyCache.PROXY_PORT}`;
                if (proxyCredentials && proxyCredentials.username) {
                    message += `${os_1.EOL}Username: ${proxyCredentials.username}`;
                }
                message += `${os_1.EOL}Proxy is Enabled`;
            }
            else {
                message = "No proxy set";
            }
            return message;
        });
    }
    getCredentials() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.$credentialsService.getCredentials(this.credentialsKey);
        });
    }
    setCredentials(credentials) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.$credentialsService.setCredentials(this.credentialsKey, credentials);
        });
    }
}
exports.ProxyService = ProxyService;
$injector.register("proxyService", ProxyService);
