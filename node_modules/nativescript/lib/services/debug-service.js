"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
const os_1 = require("os");
const events_1 = require("events");
const constants_1 = require("../constants");
class DebugService extends events_1.EventEmitter {
    constructor($devicesService, $androidDebugService, $iOSDebugService, $errors, $hostInfo, $mobileHelper) {
        super();
        this.$devicesService = $devicesService;
        this.$androidDebugService = $androidDebugService;
        this.$iOSDebugService = $iOSDebugService;
        this.$errors = $errors;
        this.$hostInfo = $hostInfo;
        this.$mobileHelper = $mobileHelper;
        this.attachConnectionErrorHandlers();
    }
    debug(debugData, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const device = this.$devicesService.getDeviceByIdentifier(debugData.deviceIdentifier);
            const debugService = this.getDebugService(device);
            if (!device) {
                this.$errors.failWithoutHelp(`Can't find device with identifier ${debugData.deviceIdentifier}`);
            }
            if (!(yield device.applicationManager.isApplicationInstalled(debugData.applicationIdentifier))) {
                this.$errors.failWithoutHelp(`The application ${debugData.applicationIdentifier} is not installed on device with identifier ${debugData.deviceIdentifier}.`);
            }
            const debugOptions = _.merge({}, options);
            debugOptions.start = true;
            const isAppRunning = true;
            let result;
            debugOptions.chrome = !debugOptions.client;
            if (this.$mobileHelper.isiOSPlatform(device.deviceInfo.platform)) {
                if (device.isEmulator && !debugData.pathToAppPackage) {
                    this.$errors.failWithoutHelp("To debug on iOS simulator you need to provide path to the app package.");
                }
                if (this.$hostInfo.isWindows) {
                    if (!isAppRunning) {
                        this.$errors.failWithoutHelp(`Application ${debugData.applicationIdentifier} is not running. To be able to debug the application on Windows you must run it.`);
                    }
                    debugOptions.emulator = false;
                }
                else if (!this.$hostInfo.isDarwin) {
                    this.$errors.failWithoutHelp(`Debugging on iOS devices is not supported for ${os_1.platform()} yet.`);
                }
                result = yield debugService.debug(debugData, debugOptions);
            }
            else if (this.$mobileHelper.isAndroidPlatform(device.deviceInfo.platform)) {
                result = yield debugService.debug(debugData, debugOptions);
            }
            return _.first(result);
        });
    }
    getDebugService(device) {
        if (this.$mobileHelper.isiOSPlatform(device.deviceInfo.platform)) {
            return this.$iOSDebugService;
        }
        else if (this.$mobileHelper.isAndroidPlatform(device.deviceInfo.platform)) {
            return this.$androidDebugService;
        }
    }
    attachConnectionErrorHandlers() {
        let connectionErrorHandler = (e) => this.emit(constants_1.CONNECTION_ERROR_EVENT_NAME, e);
        connectionErrorHandler = connectionErrorHandler.bind(this);
        this.$androidDebugService.on(constants_1.CONNECTION_ERROR_EVENT_NAME, connectionErrorHandler);
        this.$iOSDebugService.on(constants_1.CONNECTION_ERROR_EVENT_NAME, connectionErrorHandler);
    }
}
$injector.register("debugService", DebugService);
