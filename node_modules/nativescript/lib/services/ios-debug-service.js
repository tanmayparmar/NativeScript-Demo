"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
const net = require("net");
const path = require("path");
const log4js = require("log4js");
const debug_service_base_1 = require("./debug-service-base");
const constants_1 = require("../constants");
const helpers_1 = require("../common/helpers");
const byline = require("byline");
const inspectorBackendPort = 18181;
const inspectorAppName = "NativeScript Inspector.app";
const inspectorNpmPackageName = "tns-ios-inspector";
const inspectorUiDir = "WebInspectorUI/";
const TIMEOUT_SECONDS = 9;
class IOSDebugService extends debug_service_base_1.DebugServiceBase {
    constructor($platformService, $iOSEmulatorServices, $devicesService, $childProcess, $logger, $errors, $npmInstallationManager, $iOSNotification, $iOSSocketRequestExecutor, $processService, $socketProxyFactory) {
        super();
        this.$platformService = $platformService;
        this.$iOSEmulatorServices = $iOSEmulatorServices;
        this.$devicesService = $devicesService;
        this.$childProcess = $childProcess;
        this.$logger = $logger;
        this.$errors = $errors;
        this.$npmInstallationManager = $npmInstallationManager;
        this.$iOSNotification = $iOSNotification;
        this.$iOSSocketRequestExecutor = $iOSSocketRequestExecutor;
        this.$processService = $processService;
        this.$socketProxyFactory = $socketProxyFactory;
        this._sockets = [];
        this.$processService.attachToProcessExitSignals(this, this.debugStop);
        this.$socketProxyFactory.on(constants_1.CONNECTION_ERROR_EVENT_NAME, (e) => this.emit(constants_1.CONNECTION_ERROR_EVENT_NAME, e));
    }
    get platform() {
        return "ios";
    }
    debug(debugData, debugOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            if (debugOptions.debugBrk && debugOptions.start) {
                this.$errors.failWithoutHelp("Expected exactly one of the --debug-brk or --start options.");
            }
            if (this.$devicesService.isOnlyiOSSimultorRunning() || this.$devicesService.deviceCount === 0) {
                debugOptions.emulator = true;
            }
            if (debugOptions.emulator) {
                if (debugOptions.start) {
                    return [yield this.emulatorStart(debugData, debugOptions)];
                }
                else {
                    return [yield this.emulatorDebugBrk(debugData, debugOptions)];
                }
            }
            else {
                if (debugOptions.start) {
                    return this.deviceStart(debugData, debugOptions);
                }
                else {
                    return this.deviceDebugBrk(debugData, debugOptions);
                }
            }
        });
    }
    debugStart(debugData, debugOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.$devicesService.initialize({ platform: this.platform, deviceId: debugData.deviceIdentifier });
            const action = (device) => __awaiter(this, void 0, void 0, function* () { return device.isEmulator ? yield this.emulatorDebugBrk(debugData, debugOptions) : yield this.debugBrkCore(device, debugData, debugOptions); });
            yield this.$devicesService.execute(action, this.getCanExecuteAction(debugData.deviceIdentifier));
        });
    }
    debugStop() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._socketProxy) {
                this._socketProxy.close();
                this._socketProxy = null;
            }
            _.forEach(this._sockets, socket => socket.destroy());
            this._sockets = [];
            if (this._lldbProcess) {
                this._lldbProcess.stdin.write("process detach\n");
                yield this.killProcess(this._lldbProcess);
                this._lldbProcess = undefined;
            }
            if (this._childProcess) {
                yield this.killProcess(this._childProcess);
                this._childProcess = undefined;
            }
        });
    }
    killProcess(childProcess) {
        return __awaiter(this, void 0, void 0, function* () {
            if (childProcess) {
                return new Promise((resolve, reject) => {
                    childProcess.on("close", resolve);
                    childProcess.kill();
                });
            }
        });
    }
    emulatorDebugBrk(debugData, debugOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            let args = debugOptions.debugBrk ? "--nativescript-debug-brk" : "--nativescript-debug-start";
            let child_process = yield this.$iOSEmulatorServices.runApplicationOnEmulator(debugData.pathToAppPackage, {
                waitForDebugger: true,
                captureStdin: true,
                args: args,
                appId: debugData.applicationIdentifier,
                skipInstall: true
            });
            let lineStream = byline(child_process.stdout);
            this._childProcess = child_process;
            lineStream.on('data', (line) => {
                let lineText = line.toString();
                if (lineText && _.startsWith(lineText, debugData.applicationIdentifier)) {
                    const pid = helpers_1.getPidFromiOSSimulatorLogs(debugData.applicationIdentifier, lineText);
                    if (!pid) {
                        this.$logger.trace(`Line ${lineText} does not contain PID of the application ${debugData.applicationIdentifier}.`);
                        return;
                    }
                    this._lldbProcess = this.$childProcess.spawn("lldb", ["-p", pid]);
                    if (log4js.levels.TRACE.isGreaterThanOrEqualTo(this.$logger.getLevel())) {
                        this._lldbProcess.stdout.pipe(process.stdout);
                    }
                    this._lldbProcess.stderr.pipe(process.stderr);
                    this._lldbProcess.stdin.write("process continue\n");
                }
                else {
                    process.stdout.write(line + "\n");
                }
            });
            return this.wireDebuggerClient(debugData, debugOptions);
        });
    }
    emulatorStart(debugData, debugOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.wireDebuggerClient(debugData, debugOptions);
            let attachRequestMessage = this.$iOSNotification.getAttachRequest(debugData.applicationIdentifier);
            let iOSEmulator = this.$iOSEmulatorServices;
            yield iOSEmulator.postDarwinNotification(attachRequestMessage);
            return result;
        });
    }
    deviceDebugBrk(debugData, debugOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.$devicesService.initialize({ platform: this.platform, deviceId: debugData.deviceIdentifier });
            const action = (device) => __awaiter(this, void 0, void 0, function* () {
                if (device.isEmulator) {
                    return yield this.emulatorDebugBrk(debugData, debugOptions);
                }
                const runOptions = {
                    device: debugData.deviceIdentifier,
                    emulator: debugOptions.emulator,
                    justlaunch: debugOptions.justlaunch
                };
                let startApplicationAction = this.$platformService.startApplication(this.platform, runOptions, debugData.applicationIdentifier);
                const result = yield this.debugBrkCore(device, debugData, debugOptions);
                yield startApplicationAction;
                return result;
            });
            const results = yield this.$devicesService.execute(action, this.getCanExecuteAction(debugData.deviceIdentifier));
            return _.map(results, r => r.result);
        });
    }
    debugBrkCore(device, debugData, debugOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.$iOSSocketRequestExecutor.executeLaunchRequest(device.deviceInfo.identifier, TIMEOUT_SECONDS, TIMEOUT_SECONDS, debugData.applicationIdentifier, debugOptions.debugBrk);
            return this.wireDebuggerClient(debugData, debugOptions, device);
        });
    }
    deviceStart(debugData, debugOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.$devicesService.initialize({ platform: this.platform, deviceId: debugData.deviceIdentifier });
            const action = (device) => __awaiter(this, void 0, void 0, function* () { return device.isEmulator ? yield this.emulatorStart(debugData, debugOptions) : yield this.deviceStartCore(device, debugData, debugOptions); });
            const results = yield this.$devicesService.execute(action, this.getCanExecuteAction(debugData.deviceIdentifier));
            return _.map(results, r => r.result);
        });
    }
    deviceStartCore(device, debugData, debugOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.$iOSSocketRequestExecutor.executeAttachRequest(device, TIMEOUT_SECONDS, debugData.applicationIdentifier);
            return this.wireDebuggerClient(debugData, debugOptions, device);
        });
    }
    wireDebuggerClient(debugData, debugOptions, device) {
        return __awaiter(this, void 0, void 0, function* () {
            if (debugOptions.chrome) {
                this._socketProxy = yield this.$socketProxyFactory.createWebSocketProxy(this.getSocketFactory(device));
                const commitSHA = "02e6bde1bbe34e43b309d4ef774b1168d25fd024";
                return `chrome-devtools://devtools/remote/serve_file/@${commitSHA}/inspector.html?experiments=true&ws=localhost:${this._socketProxy.options.port}`;
            }
            else {
                this._socketProxy = yield this.$socketProxyFactory.createTCPSocketProxy(this.getSocketFactory(device));
                yield this.openAppInspector(this._socketProxy.address(), debugData, debugOptions);
                return null;
            }
        });
    }
    openAppInspector(fileDescriptor, debugData, debugOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            if (debugOptions.client) {
                let inspectorPath = yield this.$npmInstallationManager.getInspectorFromCache(inspectorNpmPackageName, debugData.projectDir);
                let inspectorSourceLocation = path.join(inspectorPath, inspectorUiDir, "Main.html");
                let inspectorApplicationPath = path.join(inspectorPath, inspectorAppName);
                let cmd = `open -a '${inspectorApplicationPath}' --args '${inspectorSourceLocation}' '${debugData.projectName}' '${fileDescriptor}'`;
                yield this.$childProcess.exec(cmd);
            }
            else {
                this.$logger.info("Suppressing debugging client.");
            }
        });
    }
    getSocketFactory(device) {
        const factory = () => __awaiter(this, void 0, void 0, function* () {
            const socket = device ? yield device.connectToPort(inspectorBackendPort) : net.connect(inspectorBackendPort);
            this._sockets.push(socket);
            return socket;
        });
        factory.bind(this);
        return factory;
    }
}
$injector.register("iOSDebugService", IOSDebugService);
